// Design source

`timescale 1ns / 1ps

module Receiver(
    input  wire clk,
    input  wire rst,
    input  wire Din,             // bit from photodiode: 1 = light on
    input  wire buffer_full,
    input  wire buffer_empty,
    output reg  w_en,            // byte ready to send to FIFO
    output reg  [7:0] holder,    // byte sent to FIFO
    // debug/test outputs
    output reg  [1:0] o1,
    output reg  [1:0] o2
);

    parameter Max_Bytes  = 8;     // max bytes per message
    parameter bit_period = 50;    // sample bit every 1us
    localparam threshold = 10;    // 10 clk cycles

    // Internal registers
    reg [31:0] start_counter;     
    reg [2:0]  bit_index;
    reg [1:0]  c_state, n_state;
    reg [23:0] bit_counter;
    reg [7:0]  bytes_in_message;
    reg [7:0]  byte_counter;

    wire message_incoming = (start_counter == threshold);

    // FSM states
    localparam IDLE = 1'd0;
    localparam RECEIVING = 1'd1;

    // Sequential logic (state + registers)
    always @(posedge clk or posedge rst) begin
        if (rst) begin
            c_state          <= IDLE;
            start_counter    <= 0;
            bit_counter      <= 0;
            holder           <= 0;
            bit_index        <= 0;
            w_en             <= 0;
            bytes_in_message <= 0;
            byte_counter     <= 0;
            o1               <= 0;
            o2               <= 0;
        end 
        else begin
            c_state <= n_state; // update current state

            case (c_state)
                IDLE: begin
                    w_en <= 0;
                    o1   <= 0;
                    o2   <= 0;

                    if (Din)
                        start_counter <= start_counter + 1;
                    else
                        start_counter <= 0;

                    bit_counter <= 0;
                    bit_index   <= 0;
                end

                RECEIVING: begin
                    o2 <= 1;
                    o1 <= 0;
                    w_en <= 0; // default unless byte ready

                    bit_counter <= bit_counter + 1;

                    if (bit_counter == bit_period) begin
                        bit_counter <= 0;
                        holder <= {holder[6:0], Din};
                        bit_index <= bit_index + 1;

                        if (bit_index == 3'd7) begin
                            bit_index <= 0;
                            if (bytes_in_message == 0) begin
                                // first byte tells how many bytes to expect
                                bytes_in_message <= holder;
                                byte_counter <= 1;
                                holder <= 0;
                            end
                            else begin
                                // store regular byte
                                w_en <= 1;
                                byte_counter <= byte_counter + 1;

                                if (byte_counter == bytes_in_message) begin
                                    // message done
                                    n_state <= IDLE;
                                end
                            end
                        end
                    end
                end
            endcase
        end
    end

    // Combinational next-state logic
    always @(*) begin
        n_state = c_state; // default
        case (c_state)
            IDLE: begin
                if (message_incoming)
                    n_state = RECEIVING;
            end

            RECEIVING: begin
                if (byte_counter == bytes_in_message && bytes_in_message != 0)
                    n_state = IDLE;
            end
        endcase
    end

endmodule
